package rses.inverse.mcmc;



import java.util.Random;

import rses.Model;
import rses.ModelGenerator;
import rses.inverse.UserFunctionHandle;


/** A { @link rses.ModelGenerator } that generates MCMC_Models.
 *  It does this by perturbing the current model in the chain 
 *  along a single axis. The perturbation is a Normal/Gaussian
 *  one, with a user-specified standard deviation.
 * 
 * @author peterr
 */
public final class MCMC_ModelGenerator extends ModelGenerator
{
	private MCMC_Model current;
	private double[][] bounds;
	private double[] stddevs;
	
	//NB: we use a single random number generator to generate
	//the seeds for any others, because otherwise it is
	//possible that 2 random number generators created
	//straight after one another (and seeded with the current 
	//time) will be identical, and produce identical chains 
	private static java.util.Random corerand = new java.util.Random();
	private java.util.Random rand;
	private MCMCModelGenerationMethods modgenmethod;
	private int numevdsamples = 0;

	/** Generate nummods models. 
	 * 
	 * @param modgenmethod functions to generate a new model
	 * @param start the model to start the chain with
	 * @param bounds bounds on the model space
	 * @param nummods If nummods is negative, an infinite number of models can be generated
	 * @param perturbStdDev standard deviation of the perturbation in each dimension
	 */	
	MCMC_ModelGenerator(MCMCModelGenerationMethods modgenmethod, MCMC_Model start, double[][] bounds, double[] perturbStdDevs)
	{
		this(modgenmethod, start, bounds, perturbStdDevs, 0);
	}
	
	
	/** As in MCMC_ModelGenerator(MCMCModelGenerationMethods, MCMC_Model, double[][], double[]),
	 *  but specifies that some information about the evidence (the P(d) denominator)
	 *  in Bayes rule) should be collected. This means that the appropriate
	 *  method will be set on each MCMC_Model so that the evidence information
	 *  is piggybacked on the model. See { @link MCMC_Model }. 
	 * 
	 * @param modgenmethod
	 * @param start
	 * @param bounds
	 * @param perturbStdDevs
	 * @param numEvdSamples
	 */
	MCMC_ModelGenerator(MCMCModelGenerationMethods modgenmethod, MCMC_Model start, double[][] bounds, double[] perturbStdDevs, int numEvdSamples)
	{
		if(start == null) throw new IllegalArgumentException("Start of Markov Chain cannot be null");
		if(!start.isAccepted())
			throw new IllegalArgumentException("Start of Markov Chain is a rejected model!");
		if(!start.isMisfitAvailable())	
			throw new IllegalArgumentException("Start of Markov Chain has unknown misfit!");
			
		this.rand = new Random(corerand.nextInt());
		this.modgenmethod = modgenmethod;
		current = start;
		this.bounds = bounds;
		for(int i =0; i < bounds.length; i++)
			if(perturbStdDevs[i] > 1 || perturbStdDevs[i] < 0)
				throw new IllegalArgumentException("Invalid value for perturbStdDev -- this should be between 0 and 1");
		this.stddevs = perturbStdDevs;
		this.numevdsamples = numEvdSamples;
	}

	/** Set the current model in the chain. Future models will be
	 *  generated by perturbing this model.
	 * 
	 * @param newcurrent
	 */
	public void setCurrentModel(MCMC_Model newcurrent)
	{
		if(!newcurrent.isAccepted())
			throw new IllegalArgumentException("new current model in Markov Chain is a rejected model!");
		this.current = newcurrent;
	}
	
	
	/** Gneerate the next model
	 * 
	 */
	protected Model generateModel()
	{
		UserFunctionHandle handle = this.getMisfitEvaluator();
		if(handle == null)
			throw new RuntimeException("misfit evaluator is null..... we cannot proceed.");

		//generate a new model
		double r = rand.nextDouble();
		int tochange = (int) (r*bounds.length);
		MCMC_Model m = this.modgenmethod.generateNewModel(current, rand, bounds, stddevs);
		
		//if we are estimating the evidence, we generate a model 
		//uniformly and estimate the evidence based on the
		//prior*liklihood
		double evdsum = 0.0;
		if(this.numevdsamples > 0)
		{
			for(int i =0; i < this.numevdsamples; i++)
			{
				Model uniform = new Model(bounds);
				//error is -log(prior*likelihood)
				evdsum += Math.exp(-handle.getErrorForModel(uniform.getModelParameters())); 
			}
			m.setEvidenceInformation(evdsum, this.numevdsamples);
		}
		
		//if the model is invalid, we return the current model
		if(!m.isValid())
		{
			//we update the model with the latest information about the evidence
			if(this.numevdsamples > 0) current.setEvidenceInformation(evdsum, this.numevdsamples);
			return current;
		}
		

		double[] mparams = m.getModelParameters();
		m.setMisfit(handle.getErrorForModel(mparams), handle.getPriorForModel(mparams));
		
			

		if(modgenmethod.acceptChange(current, m, rand)) 
		{
			current = m;
			current.setAccepted(true);
		}
		else
			m.setAccepted(false);
	
		return m;
	}
	
}




