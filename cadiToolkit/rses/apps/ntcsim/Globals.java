package rses.apps.ntcsim;

public class Globals 
{
	public final int citydiameter; 
	public final double gridsquare_edgekm;
	
	public final double walkbonus;
	public final double walkcostperkm;
	
	public final double bikebonus;
	public final double bikecostperkm;
	
	public final int cbdx;
	public final int cbdy;

	public final double congestionzoneradius;
	public final double congestionzone2radius;

	public final double cbdcarspeed;
	public final double congestioncordoncarspeed;
	public final double carspeedincreaseperkm;
	public final double maxcarspeed;
	

	public final double petrolcost_dollarsperkm;
	public final double carweartear_dollarsperkm;
	public final double valueoftime_dollarsperhour;
	public final double pollutioncosts_dollarsperkm;
	public final double noisecosts_dollarsperkm;
	public final double accidentcosts_dollarsperkm;
	public final double othercarcosts_perkm;
	public final double othercarcosts_pertrip;
	public final double othercarcosts_perminute;
	public final double carauxtime;

	//how much capacity is there in the central cordon (in total vkt terms) 
	public final double congestioncordon_capacity;
	public final double congestioncordon2_capacity;
	

	public final double baseParkingCost;
	public final double parkThresh0;
	public final double parkCost1;
	public final double parkThresh1;
	public final double parkCost2;
	public final double parkThresh2;
	public final double parkCost3;
	public final double parkThresh3;
	public final double parkCost4;
	
	
	public final double minptwait;
	public final double ptaux; //flat walk to public transport penalty
	public final double minptratio;
	
	public final double ptwaitweight;
	public final double ptauxweight;
	public final double ptinvweight;
	
	//these should all sum to 1
	public final double captivetravelshare;
	public final double caronlyavailable;
	public final double evonlyavailable;
	public final double carsmallevavailable;
	public final double evsmallevavailable;
	public final double smallevonlyavailable;
	
	//the number of trips generated by each activity at an origin
	public final double activitiestopopulationdivisor; 
	public final double tripsgeneratedperactivity; 
	
	//this is used to convert the dollar cost of a trip into a utility
	public final double dollartoutilityconversionfactor;
	
	//ev vars
	public final double ev1costperminute_dollars;
	public final double ev1costperkm_dollars;
	public final double ev1costpertrip_dollars;
	public final double ev1congestionfact;
	
	public final double evsmallcostperminute_dollars;
	public final double evsmallcostperkm_dollars;
	public final double evsmallcostpertrip_dollars;
	public final double evsmallparkcostratio; //0.5 means parking costs half as much, for instance
	public final double evsmallcongestionfact;
	
	//
	public final double  ptfareadjust;
	public final double ptadjust;
	
	
	public final boolean allowtransferstopt;
	public final double maxptauxdist;
	public final double maxactiveptauxdist;

	
	public final double nondiscretionarytrippct;
	
	//the transfer cost for going from some other mode to public transport, expressed in minutes
	public final double miscpttransfercost; 
	
	
	/* As people get richer, the demand for travel increases.
	 * Now, the demand is actually for destinations, so we need to adjust our
	 * utility calculation for each destination to reflect the fact that as
	 * people get richer, the demand for travel to destinations increases.
	 * We do this by inflating the 'utility' value of each destination proportionally
	 * with income. This factor allows you to do this.
	 * 
	 */
	public final double destutilityfact;
	
	
	
	/** Alternatively, we just assume that people get less sensitive to generalized cost.
	 * So, if costs increase by 1% and incomes increase by 1% then the net effect is that
	 * the two cancel out.
	 * 
	 */
	public final double distanceadjustfact;
	
	
	public double ptinvadjust = 1.0;
	public boolean modelhubs = false;

	
	public Globals(rses.spatial.util.DataStore database)
	{
		citydiameter = Integer.parseInt((String) database.lookupGlobal("citydiameter"));
		gridsquare_edgekm = Double.parseDouble((String) database.lookupGlobal("gridsquare_edgekm"));
		
		walkbonus = Double.parseDouble((String) database.lookupGlobal("walkbonus"));
		walkcostperkm = Double.parseDouble((String) database.lookupGlobal("walkcostperkm"));
		bikebonus = Double.parseDouble((String) database.lookupGlobal("bikebonus"));
		bikecostperkm = Double.parseDouble((String) database.lookupGlobal("bikecostperkm"));
		cbdx = Integer.parseInt((String) database.lookupGlobal("cbdx"));
		cbdy = Integer.parseInt((String) database.lookupGlobal("cbdy"));
		congestionzoneradius = Double.parseDouble((String) database.lookupGlobal("congestionzoneradius"));
		congestionzone2radius = Double.parseDouble((String) database.lookupGlobal("congestionzone2radius"));		
		cbdcarspeed = Double.parseDouble((String) database.lookupGlobal("cbdcarspeed"));
		maxcarspeed = Double.parseDouble((String) database.lookupGlobal("maxcarspeed"));
		carspeedincreaseperkm = Double.parseDouble((String) database.lookupGlobal("carspeedincreaseperkm"));
		
		//car generalized costs
		petrolcost_dollarsperkm = Double.parseDouble((String) database.lookupGlobal("petrolcost_perkm"));
		carweartear_dollarsperkm = 	Double.parseDouble((String) database.lookupGlobal("carweartear_perkm"));
		valueoftime_dollarsperhour = Double.parseDouble((String) database.lookupGlobal("valueoftime"));
		pollutioncosts_dollarsperkm = Double.parseDouble((String) database.lookupGlobal("pollutioncosts_perkm"));
		noisecosts_dollarsperkm = Double.parseDouble((String) database.lookupGlobal("noisecosts_perkm"));
		accidentcosts_dollarsperkm = Double.parseDouble((String) database.lookupGlobal("accidentcosts_perkm"));
		othercarcosts_perkm = Double.parseDouble((String) database.lookupGlobal("othercosts_perkm"));
		othercarcosts_pertrip = Double.parseDouble((String) database.lookupGlobal("othercosts_pertrip"));
		othercarcosts_perminute = Double.parseDouble((String) database.lookupGlobal("othercosts_perminute"));
		carauxtime = Double.parseDouble((String) database.lookupGlobal("carauxtime"));
		
		//parking costs for each square are defined by activity density
		baseParkingCost = Double.parseDouble((String) database.lookupGlobal("baseParkingCost"));
		parkThresh0 = Double.parseDouble((String) database.lookupGlobal("parkThresh0"));
		parkCost1 = Double.parseDouble((String) database.lookupGlobal("parkingCost1"));
		parkThresh1 = Double.parseDouble((String) database.lookupGlobal("parkThresh1"));
		parkCost2 = Double.parseDouble((String) database.lookupGlobal("parkingCost2"));
		parkThresh2 = Double.parseDouble((String) database.lookupGlobal("parkThresh2"));
		parkCost3 = Double.parseDouble((String) database.lookupGlobal("parkingCost3"));
		parkThresh3 = Double.parseDouble((String) database.lookupGlobal("parkThresh3"));
		parkCost4 = Double.parseDouble((String) database.lookupGlobal("parkingCost4"));
		
		tripsgeneratedperactivity = Double.parseDouble((String) database.lookupGlobal("tripsgeneratedperactivity"));
		activitiestopopulationdivisor = Double.parseDouble((String) database.lookupGlobal("activitiestopopulationdivisor"));
		
		dollartoutilityconversionfactor = Double.parseDouble((String) database.lookupGlobal("dollartoutilityconversionfactor"));
		
		//the additional capacity that is available in the congestion zone
		//this is additional capacity after the 'base' year
		congestioncordon_capacity = Double.parseDouble((String) database.lookupGlobal("congestioncosts_capacity"));
		congestioncordon2_capacity = Double.parseDouble((String) database.lookupGlobal("congestioncosts2_capacity"));
		
		if(database.lookupGlobal("congestioncordoncarspeed") == null) {
			congestioncordoncarspeed = Math.min(congestionzoneradius*carspeedincreaseperkm+cbdcarspeed, maxcarspeed); 
		}
		else
			throw new RuntimeException("specification of congestioncordoncarspeed not supported");
			//congestioncordoncarspeed = Math.min(Double.parseDouble((String) database.lookupGlobal("congestioncordoncarspeed")), maxcarspeed);


		minptwait = Double.parseDouble((String) database.lookupGlobal("minptwait"));
		ptaux = Double.parseDouble((String) database.lookupGlobal("ptaux")); 
		minptratio = Double.parseDouble((String) database.lookupGlobal("minptratio"));

		ptwaitweight = Double.parseDouble((String) database.lookupGlobal("ptwaitweight"));
		ptauxweight = Double.parseDouble((String) database.lookupGlobal("ptauxweight"));
		ptinvweight = Double.parseDouble((String) database.lookupGlobal("ptinvweight"));

				
		ev1costperminute_dollars = Double.parseDouble((String) database.lookupGlobal("ev1costperminute_dollars"));
		ev1costperkm_dollars = Double.parseDouble((String) database.lookupGlobal("ev1costperkm_dollars"));
		ev1costpertrip_dollars = Double.parseDouble((String) database.lookupGlobal("ev1costpertrip_dollars"));
		ev1congestionfact = Double.parseDouble((String) database.lookupGlobal("ev1congestionfact"));

		evsmallcostperminute_dollars = Double.parseDouble((String) database.lookupGlobal("evsmallcostperminute_dollars"));
		evsmallcostperkm_dollars = Double.parseDouble((String) database.lookupGlobal("evsmallcostperkm_dollars"));
		evsmallcostpertrip_dollars = Double.parseDouble((String) database.lookupGlobal("evsmallcostpertrip_dollars"));
		evsmallparkcostratio = Double.parseDouble((String) database.lookupGlobal("evsmallparkcostratio"));
		evsmallcongestionfact = Double.parseDouble((String) database.lookupGlobal("evsmallcongestionfact"));
		
		
		//for how many trips is a car available?
		captivetravelshare = Double.parseDouble((String) database.lookupGlobal("captivetravelshare"));
		caronlyavailable = Double.parseDouble((String) database.lookupGlobal("caronlyavailable"));
		evonlyavailable = Double.parseDouble((String) database.lookupGlobal("evonlyavailable"));
		carsmallevavailable = Double.parseDouble((String) database.lookupGlobal("carsmallevavailable"));
		evsmallevavailable = Double.parseDouble((String) database.lookupGlobal("evsmallevavailable"));
		smallevonlyavailable = Double.parseDouble((String) database.lookupGlobal("smallevonlyavailable"));
		
		if(Math.abs(1-captivetravelshare-caronlyavailable-evonlyavailable-carsmallevavailable-evsmallevavailable-smallevonlyavailable) > 0.001)
			throw new RuntimeException("Availability of different travel choices does not sum to 1! Aborting");

		//adjust pt fares and gencost by multiplying by this factor. Fares are adjusted BEFORE
		//generalized costs
		ptfareadjust = Double.parseDouble((String) database.lookupGlobal("ptfareadjust"));
		ptadjust = Double.parseDouble((String) database.lookupGlobal("ptadjust"));

		allowtransferstopt = Boolean.parseBoolean((String) database.lookupGlobal("allowtransferstopt"));
		
		maxptauxdist = Double.parseDouble((String) database.lookupGlobal("maxptauxdist"));
		maxactiveptauxdist = Double.parseDouble((String) database.lookupGlobal("maxactiveptauxdist"));
		
		//the transfer cost for going from some other mode to public transport, expressed in minutes
		miscpttransfercost = Double.parseDouble((String) database.lookupGlobal("miscpttransfercost"));
		
		nondiscretionarytrippct = Double.parseDouble((String) database.lookupGlobal("nondiscretionarytrippct"));

		destutilityfact = Double.parseDouble((String) database.lookupGlobal("destutilityfact"));
		
		distanceadjustfact = Double.parseDouble((String) database.lookupGlobal("distanceadjustfact"));
		
		if(database.lookupGlobal("modelhubs") != null)
			modelhubs = Boolean.parseBoolean((String) database.lookupGlobal("modelhubs"));
		if(database.lookupGlobal("ptinvadjust") != null)
			ptinvadjust = Double.parseDouble((String) database.lookupGlobal("ptinvadjust"));

	}

}
